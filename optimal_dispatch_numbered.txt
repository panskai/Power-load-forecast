1	import numpy as np
2	import pandas as pd
3	from typing import Dict, List, Tuple, Optional
4	import pyomo.environ as pyo
5	from pyomo.opt import SolverStatus, TerminationCondition
6	import warnings
7	
8	class OptimalDispatcher:
9	
10	    def __init__(self, config: Dict):
11	
12	        self.config = config
13	        self.generators = config.get('generators', {})
14	        self.storage = config.get('storage', {})
15	        self.constraints = config.get('constraints', {})
16	        self.solver_config = config.get('solver', {'name': 'glpk'})
17	
18	        self._validate_config()
19	
20	    def _validate_config(self):
21	
22	        required_keys = ['generators', 'storage', 'constraints']
23	        for key in required_keys:
24	            if key not in self.config:
25	                raise ValueError(f"閰嶇疆涓己灏戝繀闇€鐨勯敭: {key}")
26	
27	    def create_model(self, load_forecast: np.ndarray, time_periods: int = 96) -> pyo.ConcreteModel:
28	
29	        model = pyo.ConcreteModel()
30	
31	        model.T = pyo.RangeSet(1, time_periods)  
32	        model.G = pyo.Set(initialize=list(self.generators.keys()))  
33	        model.S = pyo.Set(initialize=list(self.storage.keys()))     
34	
35	        model.demand = pyo.Param(model.T, initialize=dict(enumerate(load_forecast, 1)))
36	
37	        model.P_g = pyo.Var(model.G, model.T, 
38	                           domain=pyo.NonNegativeReals,
39	                           doc="鏈虹粍鍑哄姏 [MW]")
40	
41	        model.E_s = pyo.Var(model.S, model.T, 
42	                           domain=pyo.Reals,
43	                           doc="鍌ㄨ兘鍏呮斁鐢靛姛鐜?[MW]")
44	
45	        model.SOC = pyo.Var(model.S, model.T,
46	                           domain=pyo.NonNegativeReals,
47	                           doc="鍌ㄨ兘鑽风數鐘舵€?[MWh]")
48	
49	        self._add_constraints(model)
50	
51	        self._add_objective(model)
52	
53	        return model
54	
55	    def _add_constraints(self, model: pyo.ConcreteModel):
56	
57	        def supply_demand_balance_rule(model, t):
58	
59	            return (sum(model.P_g[g, t] for g in model.G) + 
60	                   sum(model.E_s[s, t] for s in model.S) == 
61	                   model.demand[t])
62	
63	        model.supply_demand_balance = pyo.Constraint(
64	            model.T, rule=supply_demand_balance_rule,
65	            doc="渚涢渶骞宠　绾︽潫"
66	        )
67	
68	        def generator_min_output_rule(model, g, t):
69	
70	            gen_data = self.generators[g]
71	            return model.P_g[g, t] >= gen_data['p_min']
72	
73	        def generator_max_output_rule(model, g, t):
74	
75	            gen_data = self.generators[g]
76	            return model.P_g[g, t] <= gen_data['p_max']
77	
78	        model.generator_min_output = pyo.Constraint(
79	            model.G, model.T, 
80	            rule=generator_min_output_rule,
81	            doc="鏈虹粍鏈€灏忓嚭鍔涚害鏉?
82	        )
83	
84	        model.generator_max_output = pyo.Constraint(
85	            model.G, model.T, 
86	            rule=generator_max_output_rule,
87	            doc="鏈虹粍鏈€澶у嚭鍔涚害鏉?
88	        )
89	
90	        def ramp_up_constraint_rule(model, g, t):
91	
92	            if t == 1:
93	                return pyo.Constraint.Skip
94	            gen_data = self.generators[g]
95	            ramp_up = gen_data.get('ramp_up', float('inf'))
96	            return model.P_g[g, t] - model.P_g[g, t-1] <= ramp_up
97	
98	        def ramp_down_constraint_rule(model, g, t):
99	
100	            if t == 1:
101	                return pyo.Constraint.Skip
102	            gen_data = self.generators[g]
103	            ramp_down = gen_data.get('ramp_down', float('inf'))
104	            return model.P_g[g, t-1] - model.P_g[g, t] <= ramp_down
105	
106	        model.ramp_up_constraint = pyo.Constraint(
107	            model.G, model.T, rule=ramp_up_constraint_rule,
108	            doc="鏈虹粍鍚戜笂鐖潯绾︽潫"
109	        )
110	
111	        model.ramp_down_constraint = pyo.Constraint(
112	            model.G, model.T, rule=ramp_down_constraint_rule,
113	            doc="鏈虹粍鍚戜笅鐖潯绾︽潫"
114	        )
115	
116	        def storage_soc_bounds_rule(model, s, t):
117	
118	            storage_data = self.storage[s]
119	            return (storage_data['soc_min'], 
120	                   model.SOC[s, t], 
121	                   storage_data['soc_max'])
122	
123	        model.storage_soc_bounds = pyo.Constraint(
124	            model.S, model.T, 
125	            rule=storage_soc_bounds_rule,
126	            doc="鍌ㄨ兘SOC绾︽潫"
127	        )
128	
129	        def storage_soc_dynamic_rule(model, s, t):
130	
131	            if t == 1:
132	
133	                storage_data = self.storage[s]
134	                initial_soc = storage_data.get('initial_soc', storage_data['soc_max'] * 0.5)
135	                return model.SOC[s, t] == initial_soc - model.E_s[s, t] * 0.25  
136	            else:
137	
138	                efficiency = self.storage[s].get('efficiency', 0.95)
139	                dt = 0.25  
140	
141	                return model.SOC[s, t] == model.SOC[s, t-1] - model.E_s[s, t] * dt / efficiency
142	
143	        model.storage_soc_dynamic = pyo.Constraint(
144	            model.S, model.T, 
145	            rule=storage_soc_dynamic_rule,
146	            doc="鍌ㄨ兘SOC鍔ㄦ€佺害鏉?
147	        )
148	
149	        def storage_power_bounds_rule(model, s, t):
150	
151	            storage_data = self.storage[s]
152	            return (-storage_data['p_max'], 
153	                   model.E_s[s, t], 
154	                   storage_data['p_max'])
155	
156	        model.storage_power_bounds = pyo.Constraint(
157	            model.S, model.T, 
158	            rule=storage_power_bounds_rule,
159	            doc="鍌ㄨ兘鍔熺巼绾︽潫"
160	        )
161	
162	        if 'carbon_limit' in self.constraints:
163	            def carbon_emission_rule(model, t):
164	
165	                total_emission = sum(
166	                    model.P_g[g, t] * self.generators[g].get('emission_factor', 0)
167	                    for g in model.G
168	                )
169	                return total_emission <= self.constraints['carbon_limit']
170	
171	            model.carbon_emission = pyo.Constraint(
172	                model.T, rule=carbon_emission_rule,
173	                doc="纰虫帓鏀剧害鏉?
174	            )
175	
176	    def _add_objective(self, model: pyo.ConcreteModel):
177	
178	        def objective_rule(model):
179	
180	            generator_cost = sum(
181	                self._generator_cost(model.P_g[g, t], g) 
182	                for g in model.G for t in model.T
183	            )
184	
185	            storage_cost = sum(
186	                self._storage_cost(model.E_s[s, t], s)
187	                for s in model.S for t in model.T
188	            )
189	
190	            emission_penalty = 0
191	            if 'carbon_penalty' in self.constraints:
192	                lambda_carbon = self.constraints['carbon_penalty']
193	                emission_penalty = sum(
194	                    lambda_carbon * model.P_g[g, t] * 
195	                    self.generators[g].get('emission_factor', 0)
196	                    for g in model.G for t in model.T
197	                )
198	
199	            return generator_cost + storage_cost + emission_penalty
200	
201	        model.obj = pyo.Objective(rule=objective_rule, sense=pyo.minimize)
202	
203	    def _generator_cost(self, power: pyo.Var, gen_id: str) -> pyo.Expression:
204	
205	        gen_data = self.generators[gen_id]
206	
207	        b = gen_data.get('cost_b', 20)    
208	        c = gen_data.get('cost_c', 100)   
209	
210	        return b * power + c
211	
212	    def _storage_cost(self, power: pyo.Var, storage_id: str) -> pyo.Expression:
213	
214	        storage_data = self.storage[storage_id]
215	        cost_per_mwh = storage_data.get('cost_per_mwh', 5)  
216	
217	        return cost_per_mwh * power * 0.25  
218	
219	    def solve(self, model: pyo.ConcreteModel, 
220	              compensation: Optional[np.ndarray] = None) -> Dict:
221	
222	        if compensation is not None:
223	
224	            demand_dict = {}
225	            for t in model.T:
226	                original_demand = pyo.value(model.demand[t])
227	                compensated_demand = original_demand + compensation[t-1]
228	                demand_dict[t] = compensated_demand
229	
230	            model.del_component(model.demand)
231	            model.demand = pyo.Param(model.T, initialize=demand_dict)
232	
233	        solver_name = self.solver_config.get('name', 'glpk')
234	        try:
235	            solver = pyo.SolverFactory(solver_name)
236	        except Exception:
237	            print(f"璀﹀憡锛氭棤娉曟壘鍒版眰瑙ｅ櫒 {solver_name}锛屽皾璇曚娇鐢?glpk")
238	            solver = pyo.SolverFactory('glpk')
239	
240	        solver_options = self.solver_config.get('options', {})
241	        for key, value in solver_options.items():
242	            solver.options[key] = value
243	
244	        try:
245	            results = solver.solve(model, tee=False)
246	
247	            if (results.solver.status == SolverStatus.ok and 
248	                results.solver.termination_condition == TerminationCondition.optimal):
249	
250	                return self._extract_solution(model, results)
251	            else:
252	                raise RuntimeError(f"姹傝В澶辫触: {results.solver.termination_condition}")
253	
254	        except Exception as e:
255	            raise RuntimeError(f"姹傝В杩囩▼涓嚭鐜伴敊璇? {e}")
256	
257	    def _extract_solution(self, model: pyo.ConcreteModel, results) -> Dict:
258	
259	        solution = {
260	            'status': 'optimal',
261	            'objective_value': pyo.value(model.obj),
262	            'generator_output': {},
263	            'storage_output': {},
264	            'storage_soc': {},
265	            'total_cost': pyo.value(model.obj),
266	            'supply_demand': []
267	        }
268	
269	        for g in model.G:
270	            solution['generator_output'][g] = [
271	                pyo.value(model.P_g[g, t]) for t in model.T
272	            ]
273	
274	        for s in model.S:
275	            solution['storage_output'][s] = [
276	                pyo.value(model.E_s[s, t]) for t in model.T
277	            ]
278	            solution['storage_soc'][s] = [
279	                pyo.value(model.SOC[s, t]) for t in model.T
280	            ]
281	
282	        for t in model.T:
283	            supply = sum(pyo.value(model.P_g[g, t]) for g in model.G)
284	            storage = sum(pyo.value(model.E_s[s, t]) for s in model.S)
285	            demand = pyo.value(model.demand[t])
286	            solution['supply_demand'].append({
287	                'time': t,
288	                'supply': supply,
289	                'storage': storage,
290	                'demand': demand,
291	                'balance': supply + storage - demand
292	            })
293	
294	        return solution
295	
296	    def calculate_metrics(self, solution: Dict, actual_load: Optional[np.ndarray] = None) -> Dict:
297	
298	        metrics = {
299	            'total_cost': solution['total_cost'],
300	            'avg_cost_per_mwh': 0,
301	            'carbon_emission': 0,
302	            'renewable_utilization': 0,
303	            'generator_adjustments': 0,
304	            'max_prediction_error': 0
305	        }
306	
307	        total_generation = 0
308	        for g, output in solution['generator_output'].items():
309	            total_generation += sum(output)
310	
311	        if total_generation > 0:
312	            metrics['avg_cost_per_mwh'] = solution['total_cost'] / total_generation
313	
314	        for g, output in solution['generator_output'].items():
315	            emission_factor = self.generators[g].get('emission_factor', 0)
316	            metrics['carbon_emission'] += sum(p * emission_factor for p in output)
317	
318	        total_adjustments = 0
319	        for g, output in solution['generator_output'].items():
320	            for i in range(1, len(output)):
321	                if abs(output[i] - output[i-1]) > 1.0:  
322	                    total_adjustments += 1
323	        metrics['generator_adjustments'] = total_adjustments
324	
325	        if actual_load is not None:
326	            forecast_load = [item['demand'] for item in solution['supply_demand']]
327	            errors = [abs(actual_load[i] - forecast_load[i]) 
328	                     for i in range(min(len(actual_load), len(forecast_load)))]
329	            if errors:
330	                metrics['max_prediction_error'] = max(errors)
331	
332	        return metrics
